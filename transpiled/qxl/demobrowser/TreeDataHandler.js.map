{
  "version": 3,
  "sources": [
    "/home/runner/work/qxl.demobrowser/qxl.demobrowser/source/class/qxl/demobrowser/TreeDataHandler.js"
  ],
  "names": [
    "qx",
    "Bootstrap",
    "executePendingDefers",
    "$$dbClassInfo",
    "Class",
    "define",
    "extend",
    "core",
    "Object",
    "construct",
    "testRep",
    "tmap",
    "ttree",
    "__readTestRep",
    "members",
    "insert",
    "root",
    "el",
    "mclass",
    "classname",
    "path",
    "split",
    "createPath",
    "parent",
    "length",
    "head",
    "pathrest",
    "slice",
    "target",
    "nextRoot",
    "children",
    "getChildren",
    "i",
    "label",
    "qxl",
    "demobrowser",
    "Tree",
    "add",
    "Error",
    "that",
    "readTree",
    "topsort",
    "a",
    "b",
    "sort",
    "struct",
    "node",
    "tree",
    "arguments",
    "mysort",
    "name",
    "tests",
    "j",
    "tags",
    "ignoreNode",
    "Environment",
    "get",
    "k",
    "type",
    "desc",
    "manifest",
    "subTree",
    "getRoot",
    "Root",
    "getChilds",
    "cldList",
    "nodep",
    "pat",
    "RegExp",
    "match",
    "push",
    "getTests",
    "getPath",
    "pwd",
    "shift",
    "isClass",
    "concat",
    "classes",
    "hasTests",
    "classFromTest",
    "classloop",
    "getFullName",
    "join",
    "getPreviousNode",
    "prevNode",
    "getPrevSibling",
    "getNextNode",
    "nextNode",
    "getNextSibling",
    "testCount",
    "num",
    "iter",
    "getIterator",
    "curr",
    "environment",
    "destruct",
    "_disposeObjects",
    "TreeDataHandler"
  ],
  "mappings": "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",
  "sourcesContent": [
    "/* ************************************************************************\n\n   qooxdoo - the new era of web development\n\n   http://qooxdoo.org\n\n   Copyright:\n     2007-2008 1&1 Internet AG, Germany, http://www.1und1.de\n\n   License:\n     MIT: https://opensource.org/licenses/MIT\n     See the LICENSE file in the project's top-level directory for details.\n\n   Authors:\n     * Thomas Herchenroeder (thron7)\n     * Fabian Jakobs (fjakobs)\n\n************************************************************************ */\n\nqx.Class.define(\"qxl.demobrowser.TreeDataHandler\",\n{\n  extend : qx.core.Object,\n\n\n  /*\n  *****************************************************************************\n     CONSTRUCTOR\n  *****************************************************************************\n  */\n\n  construct : function(testRep)\n  {\n    this.base(arguments);\n\n    this.tmap = testRep;\n    this.ttree = this.__readTestRep(testRep);\n  },\n\n\n\n\n  /*\n  *****************************************************************************\n     MEMBERS\n  *****************************************************************************\n  */\n\n  members :\n  {\n    /**\n     * TODOC\n     *\n     * @param testRep {var} TODOC\n     * @return {var} TODOC\n     * @throws {Error} TODOC\n     */\n    __readTestRep : function(testRep)\n    {\n      var tmap = testRep;\n\n      function insert(root, el)\n      {\n        var mclass = el.classname;\n        var path = mclass.split(\".\");\n\n\n        /**\n         * create a new tree path from path, under parent node\n         */\n        function createPath(parent, path)\n        {\n          if (!path.length)  // never do \"path == []\"\n          {\n            return parent;\n          }\n          else\n          {\n            var head = path[0];\n            var pathrest = path.slice(1, path.length);\n            var target = null;\n            var nextRoot = null;\n\n            // check children\n            var children = parent.getChildren();\n\n            for (var i=0; i<children.length; i++)\n            {\n              if (children[i].label == head)\n              {\n                nextRoot = children[i];\n                break;\n              }\n            }\n\n            // else create new\n            if (nextRoot == null)\n            {\n              nextRoot = new qxl.demobrowser.Tree(head);\n              parent.add(nextRoot);\n            }\n\n            // and recurse with the new root and the rest of path\n            target = createPath(nextRoot, pathrest);\n            return target;\n          }\n        }\n\n        var target = createPath(root, path);\n\n        if (!target) {\n          throw new Error(\"No target to insert tests\");\n        }\n\n        that.readTree(el, target);\n      }\n\n      function topsort(a, b)\n      {\n        return (a.classname < b.classname) ? -1 : (a.classname > b.classname) ? 1 : 0;\n      }\n\n      var root = new qxl.demobrowser.Tree(\"All\");\n      var that = this;\n\n      tmap.sort(topsort);\n\n      for (var i=0; i<tmap.length; i++) {\n        insert(root, tmap[i]);\n      }\n\n      return root;\n    },\n\n\n    /**\n     * recursive struct reader\n     *\n     * @param struct {var} TODOC\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     */\n    readTree : function(struct, node)  // struct has single root node!\n    {\n      // current node\n      var tree = arguments[1] || new qxl.demobrowser.Tree(struct.classname);\n      var node;\n\n      // current test leafs\n      function mysort(a, b) {\n        return (a.name < b.name) ? -1 : (a.name > b.name) ? 1 : 0;\n      }\n\n      if (struct.tests) {\n        struct.tests.sort(mysort);\n\n        for (var j=0; j<struct.tests.length; j++)\n        {\n          var tags = struct.tests[j].tags;\n          var ignoreNode = false;\n\n          if (!qx.core.Environment.get(\"qxl.demobrowser.withTests\"))\n          {\n            for (var k=0; k < tags.length; k++)\n            {\n              if (tags[k] === \"test\")\n              {\n                ignoreNode = true;\n                break;\n              }\n            }\n          }\n\n          if (!ignoreNode)\n          {\n            node = new qxl.demobrowser.Tree(struct.tests[j].name);\n            node.tags = struct.tests[j].tags;\n            node.type = \"test\";  // tests are leaf nodes\n            node.desc = struct.tests[j].desc;\n            node.manifest = struct.tests[j].manifest;\n            tree.add(node);\n          }\n        }\n      }\n\n      // current children\n      if (struct.children && struct.children.length)\n      {\n        for (var j=0; j<struct.children.length; j++) {\n          var subTree = this.readTree(struct.children[j]);\n          if (qx.core.Environment.get(\"qx.contrib\") == true) {\n            if (struct.children[j].manifest) {\n              subTree.manifest = struct.children[j].manifest;\n            }\n            if (struct.children[j].tags) {\n              subTree.tags = struct.children[j].tags;\n            }\n            if (struct.children[j].jobsExecuted) {\n              subTree.jobsExecuted = struct.children[j].jobsExecuted;\n            }\n          }\n          tree.add(subTree);\n        }\n      }\n\n      if (qx.core.Environment.get(\"qx.contrib\") == true) {\n        if (struct.readme) {\n          tree.readme = struct.readme;\n        }\n      }\n\n      return tree;\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @return {var} TODOC\n     */\n    getRoot : function()\n    {\n      if (!this.Root)\n      {\n        var root =\n        {\n          classname : \"\",\n          tests     : []\n        };\n\n        var tmap = this.tmap;\n\n        for (var i=0; i<this.tmap.length; i++)\n        {\n          if (root.classname.length > tmap[i].classname.length) {\n            root = tmap[i];\n          }\n        }\n\n        this.Root = root;\n      }\n\n      return this.Root.classname;\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     */\n    getChilds : function(node)\n    {\n      var cldList = [];\n      var tmap = this.tmap;\n      var nodep = \"^\" + node + \"\\\\.[^\\\\.]+$\";\n      var pat = new RegExp(nodep);\n\n      for (var i=0; i<tmap.length; i++)\n      {\n        if (tmap[i].classname.match(pat)) {\n          cldList.push(tmap[i]);\n        }\n      }\n\n      return cldList;\n    },\n\n    /*\n     * get the tests directly contained in a class\n     */\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var | Array} TODOC\n     */\n    getTests : function(node)\n    {  // node is a string\n      var tmap = this.tmap;\n\n      for (var i=0; i<tmap.length; i++)\n      {\n        if (tmap[i].classname == node) {\n          return tmap[i].tests;\n        }\n      }\n\n      return [];\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     */\n    getPath : function(node)\n    {  // node is a modelNode\n      if (!node) {\n        return \"\";\n      }\n\n      var path = node.pwd();\n      path.shift();  // remove leading 'All'\n\n      // var tclass = path.join(\".\")+\".\"+node.label;\n      if (this.isClass(node)) {\n        path = path.concat(node.label);\n      }\n\n      return path;\n    },\n\n\n    /**\n     * @param node {String} a class or test name\n     * @return {var | Array} TODOC\n     */\n    getChildren : function(node)\n    {\n      if (node == \"All\")\n      {\n        var tmap = this.tmap;\n        var classes = [];\n\n        for (var i=0; i<tmap.length; i++) {\n          classes.push(tmap[i].classname);\n        }\n\n        return classes;\n      }\n      else if (this.isClass(node))\n      {\n        return this.getTests(node);\n      }\n      else\n      {\n        return [];\n      }\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {boolean} TODOC\n     */\n    isClass : function(node)\n    {\n      if (node.type && node.type == \"test\") {\n        return false;\n      } else {\n        return true;\n      }\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {boolean} TODOC\n     */\n    hasTests : function(node)\n    {\n      if (!this.isClass(node))\n      {\n        return false;\n      }\n      else\n      {\n        var children = node.getChildren();\n\n        for (var i=0; i<children.length; i++)\n        {\n          if (children[i].type && children[i].type == \"test\") {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     * @lint ignoreUnused(tests)\n     * @ignore(classloop) Workaround for bug #2221\n     */\n    classFromTest : function(node)\n    {\n      var classname = \"\";\n      var tests = [];\n\n      classloop:\n      for (var i=0; i<this.tmap.length; i++)\n      {\n        for (var j=0; j<this.tmap[i].tests.length; j++)\n        {\n          if (this.tmap[i].tests[j] == node)\n          {\n            classname = this.tmap[i].classname;\n            break classloop;\n          }\n        }\n      }\n\n      return classname;\n    },\n\n\n    /**\n     * return the full name of a test from its model node\n     *\n     * @param node {Tree} a model node\n     * @return {var} fullName {String} like \"qxl.demobrowser.test.Class.testEmptyClass\"\n     */\n    getFullName : function(node)  // node is a tree node\n    {\n      if (!node) {\n        return \"\";\n      }\n\n      var path = this.getPath(node);\n\n      if (node.type && node.type == \"test\") {\n        path = path.concat(node.label);\n      }\n\n      return path.join(\".\");\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     */\n    getPreviousNode : function(node)  // node is tree node\n    {\n      var prevNode = node.getPrevSibling();\n\n      if (prevNode) {\n        return prevNode;\n      }\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {var} TODOC\n     */\n    getNextNode : function(node)  // node is a tree node\n    {\n      var nextNode = node.getNextSibling();\n\n      if (nextNode) {\n        return nextNode;\n      }\n    },\n\n\n    /**\n     * TODOC\n     *\n     * @param node {Node} TODOC\n     * @return {int | Number} TODOC\n     */\n    testCount : function(node)\n    {  // node is a tree node\n      if (node.type && node.type == \"test\") {\n        return 1;\n      }\n      else\n      {  // enumerate recursively\n        var num = 0;\n        var iter = node.getIterator(\"depth\");\n        var curr;\n\n        while (curr = iter())\n        {\n          if (curr.type && curr.type == \"test\") {\n            num++;\n          }\n        }\n\n        return num;\n      }\n    }\n  },\n\n  environment : {\n    \"qxl.demobrowser.withTests\" : false\n  },\n\n\n  /*\n  *****************************************************************************\n     DESTRUCTOR\n  *****************************************************************************\n  */\n\n  destruct : function()\n  {\n    this.tmap = null;\n    this._disposeObjects(\"ttree\");\n  }\n});\n"
  ]
}